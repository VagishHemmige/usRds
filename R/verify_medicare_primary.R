#' Verify that a patient has Medicare primary coverage
#'
#' This function accepts a data frame `df`, an index date option `index_date` which is either a fixed date or
#' the name of a date variable in quotes, and a variable `lookback_days` that encodes how many days of Medicare
#' coverage are necessary.
#'
#' An optional variable `medicare_coverage_df` allows for a df containing information from the `payhist` file to be passed to the function.  If left
#' NULL, then the function will load the data via the `load_usrds_file` function, which can be very inefficient for multiple function calls.
#'
#' It returns the same dataframe with a new variable `medicare_primary_TF` that takes the values `TRUE`
#' or `FALSE`.
#'
#' Optionally, the start dates and end dates of Medicare primary coverage for that coverage spell can also be returned by specifying names for
#' the return variables in the `coverage_start_variable` and `coverage_end_variable` parameters.  If unspecified, these parameters will not be returned.
#'
#' For repeated use, setting `cache`=TRUE will either cache or use the processed version of the Medicare coverage file
#' (whether generated by the function or derived from the `medicare_coverage_df` passed to the function).
#'
#' @param df is a data frame, presumably one with a single row per patient.  Data frame *must* contain
#' a column named `USRDS_ID`.
#'
#' @param index_date either a fixed date or the name of a date variable in quotes
#'
#' @param lookback_days is the number of days of Medicare as primary necessary.  Default value is 365.
#'
#' @param medicare_coverage_df is an optional parameter containing a df from the `payhist` file.
#'
#' @param coverage_start_variable is the name of the variable containing the start date of Medicare primary coverage for the coverage spell containing the
#' `index_date`.  The default value of NULL specifies no variable returned.
#'
#' @param coverage_end_variable is the name of the variable containing the end date of Medicare primary coverage for the coverage spell containing the
#' `index_date`.  The default value of NULL specifies no variable returned.
#'
#' @param cache whether or not to cache, or use a previously cached version, of the medicare coverage data frame.  This can save substantial amounts of
#' time in a loop.
#'
#' @return The original `df` data fame with the variable `medicare_primary_TF` added
#'
#' @export
#'
#' @examples
#' \dontrun{
#'
#' test_df<-data.frame(
#' USRDS_ID=c(30, 111112),
#' initial_dates=as.Date(c("1994-01-01", "2019-01-01"))
#' )
#'
#'verify_medicare_primary(df=test_df, index_date = "initial_dates", lookback_days = 365)
#'
#' }

verify_medicare_primary<-function(df, index_date, lookback_days=365, medicare_coverage_df=NULL,
                                  coverage_start_variable=NULL, coverage_end_variable=NULL, cache=FALSE)
{

  #Error checking

  #Check that df is an appropriate data frame
  if (!inherits(df, "data.frame")) {
    rlang::abort("`df` must be a data frame.")
  }

  #Check that medicare_coverage_df is an appropriate data frame
  if (!inherits(medicare_coverage_df, "data.frame") && !is.null(medicare_coverage_df)) {
    rlang::abort("`medicare_coverage_df` must be a data frame or NULL.")
  }

  if (nrow(df) == 0) {
    rlang::abort("`df` must have at least one row.")
  }

  if (!"USRDS_ID" %in% names(df)) {
    rlang::abort("`df` must contain a column named `USRDS_ID`.")
  }

  if (!is.null(medicare_coverage_df) &&
      !"USRDS_ID" %in% names(medicare_coverage_df)) {
    rlang::abort("`medicare_coverage_df` must contain a column named `USRDS_ID`.")
  }

  if (all(is.na(df$USRDS_ID))) {
    rlang::abort("`df$USRDS_ID` cannot be all missing.")
  }

  #Confirm that index_date is of the right form
  if (inherits(index_date, "Date")) {
    # ok
  } else if (is.character(index_date) && length(index_date) == 1) {
    if (!index_date %in% names(df)) {
      rlang::abort("`index_date` must be a Date or the name of a date column in `df`.")
    }
    if (!inherits(df[[index_date]], "Date")) {
      rlang::abort(
        paste0("`df$", index_date, "` must be of class Date.")
      )
    }
  } else {
    rlang::abort(
      "`index_date` must be a Date or a single character string naming a Date column in `df`."
    )
  }


  #Verify that lookback_days is an integer greater than zero.
  if (!is.numeric(lookback_days) ||
      length(lookback_days) != 1 ||
      lookback_days <= 0 ||
      lookback_days %% 1 != 0) {
    rlang::abort(
      "`lookback_days` must be a single integer greater than 0."
    )
  }

  if (is.character(index_date)) {
    if (any(is.na(df[[index_date]]))) {
      rlang::warn(
        paste0("`df$", index_date, "` contains missing values; ",
               "these patients will be classified as FALSE.")
      )
    }
  }

  #Warning if df containus USRDS_IDs that are not in the medicare_coverage_df (assuming the latter is not NULL)
  if (!is.null(medicare_coverage_df)) {

    missing_ids <- setdiff(df$USRDS_ID, medicare_coverage_df$USRDS_ID)

    if (length(missing_ids) > 0) {
      rlang::warn(glue::glue(
        "{length(missing_ids)} USRDS_ID(s) in `df` are not present in `medicare_coverage_df`."
      ))
    }
  }

  if (!is.null(medicare_coverage_df)) {
    required_cols <- c("USRDS_ID", "PAYER", "BEGDATE", "ENDDATE")
    missing <- setdiff(required_cols, names(medicare_coverage_df))
    if (length(missing) > 0) {
      rlang::abort(
        paste0("`medicare_coverage_df` is missing required columns: ",
               paste(missing, collapse = ", "))
      )
    }
  }

  if (!is.null(coverage_start_variable)) {
    if (!is.character(coverage_start_variable) || length(coverage_start_variable)>1) {
      rlang::abort("`coverage_start_variable` must be NULL or a single character string.")
    } else
    if (coverage_start_variable %in% names(df)){
      rlang::abort("Value of `coverage_start_variable` must not already be a variable in `df`.")
    }
  }

  if (!is.null(coverage_end_variable)) {
    if (!is.character(coverage_end_variable) || length(coverage_end_variable)>1) {
      rlang::abort("`coverage_end_variable` must be NULL or a single character string.")
    } else
      if (coverage_end_variable %in% names(df)){
        rlang::abort("Value of `coverage_end_variable` must not already be a variable in `df`.")
      }
  }

  if (!is.logical(cache) || length(cache) != 1 || is.na(cache)) {
    rlang::abort("`cache` must be a single TRUE or FALSE value.")
  }

#--------------------------------------------------------------------------------------------

  # Now we begin the code which executes the purpose of the function

  #Convert index_date if necessary to something that can be used
  if (is.character(index_date) && length(index_date) == 1) {
    index_date_var <- rlang::sym(index_date)
    df <- df %>% mutate(.index_date = !!index_date_var)
  } else {
    df <- df %>% mutate(.index_date = as.Date(index_date))
  }


#Define eligible payers
eligible_payers <- c(
  "MEDICARE FFS PRIMARY PAY, FOR BOTH PART A AND PART B",
  "MEDICARE FFS PRIMARY PAY, FOR OTHER"
)

#Open Medicare history file, keep rows where the payer is Medicare primary, and sort by USRDS and date

if (cache==TRUE && exists("medicare_history", envir = .usrds_env, inherits = FALSE))
{
  medicare_history<-.usrds_env$medicare_history
} else {

  if (is.null(medicare_coverage_df)) {
    medicare_history<-load_usrds_file("payhist",
                                      usrds_ids = df$USRDS_ID)
    } else {
      medicare_history<-medicare_coverage_df}

  medicare_history<-medicare_history%>%
    filter(PAYER %in% eligible_payers) %>%
    select(USRDS_ID, BEGDATE, ENDDATE)%>%
    arrange(USRDS_ID, BEGDATE)%>%

    #Combine lines where there is no gap between the lines and they are the same patient
    group_by(USRDS_ID) %>%
    arrange(BEGDATE, .by_group = TRUE) %>%
    mutate(
      prev_end = lag(ENDDATE),

      # start a new group if there is a gap
      new_group = if_else(
        is.na(prev_end) | BEGDATE > prev_end + days(1),
        1L,
        0L
        ),
      group_id = cumsum(new_group)
      ) %>%
    group_by(USRDS_ID, group_id) %>%
    summarise(
      BEGDATE = min(BEGDATE),
      ENDDATE = max(ENDDATE),
      .groups = "drop"
      )%>%
    select(-group_id)%>%
    rename(usrds_package_medicare_begdate = BEGDATE,
           usrds_package_medicare_enddate = ENDDATE)

}

if (cache==TRUE && !exists("medicare_history", envir = .usrds_env, inherits = FALSE))
{
  .usrds_env$medicare_history<-medicare_history
  rlang::inform("Current Medicare coverage df being cached for future use...")
}

#Join patient cohort to medicare history data
patients_clean<-left_join(df,
                          medicare_history,
                          join_by(USRDS_ID, between(.index_date, usrds_package_medicare_begdate, usrds_package_medicare_enddate))
)

#Create variable that marks FFS coverage on day of claim through 365 days prior
#Logic here depends strongly on nature of between join in dplyr
patients_clean<-patients_clean%>%
  mutate(medicare_primary_TF=ifelse(!is.na(usrds_package_medicare_begdate) & .index_date-usrds_package_medicare_begdate>=lookback_days,TRUE,FALSE))%>%

  #Rename start and end variables for coverage to user specified variables if not null
  { if (!is.null(coverage_start_variable)) dplyr::mutate(.,!!rlang::sym(coverage_start_variable):=usrds_package_medicare_begdate) else . }%>%
  { if (!is.null(coverage_end_variable)) dplyr::mutate(.,!!rlang::sym(coverage_end_variable):=usrds_package_medicare_enddate) else . }


patients_clean<-patients_clean%>%
  select(-.index_date, -usrds_package_medicare_begdate, -usrds_package_medicare_enddate)

return(patients_clean)

}
